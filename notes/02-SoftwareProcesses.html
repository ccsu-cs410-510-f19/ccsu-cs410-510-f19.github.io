<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>CS 410/510 - Software Engineering class notes</title>
<link rel="stylesheet" type="text/css" href="../css/notes.css">
</head>

<body>

<div class="SimpleTitle">

<p>CS 410/510 - Software Engineering</p>
<p>Software Processes</p>

</div>

<div class="Content">

<p>Reference: Sommerville, Software Engineering, 10 ed., Chapter 2</p>


<div class="Underhead">
<p>The big picture</p></div>


<p>A software process is a structured set of activities required to develop a software system. Note that we are talking about a "software process" -- not a "software <i>development</i> process."</p>

<p>There are many different kinds of software processes, but each and every one of them involve these four types of fundamental activities:</p>

<ul>
	<li>Software <b>specification</b> - defining what the system should do;</li>
	<li>Software <b>design and implementation</b> - defining the organization of the system and implementing the system;</li>
	<li>Software <b>validation</b> - checking that it does what the customer wants;</li>
	<li>Software <b>evolution</b> - changing the system in response to changing customer needs.</li>
</ul>

<p>A software process model is an abstract representation of a process. It presents a description of a process from some particular perspective. When we describe and discuss software processes, we usually talk about the activities in these processes such as specifying a data model, designing a user interface, etc. and the ordering of these activities.
Process descriptions may also include:</p>
<ul>
	<li><b>Products</b>, which are the outcomes of a process activity; </li>
	<li><b>Roles</b>, which reflect the responsibilities of the people involved in the process;</li>
	<li>Pre- and post-<b>conditions</b>, which are statements that are true before and after a process activity has been enacted or a product produced. </li>
</ul>

<p><b>Plan-driven</b> processes are processes where all of the process activities are planned in advance and progress is measured against this plan.
In <b>agile</b> processes, planning is incremental and it is easier to change the process to reflect changing customer requirements.
In practice, most practical processes include elements of both plan-driven and agile approaches. </p>





<div class="Underhead">
<p>Software process models</p>
</div>

<dl>
	<dt>The waterfall model</dt>
	<dd>Plan-driven model. Separate and distinct phases of specification, software design, implementation, testing, and maintenance.</dd>

	<dt>Incremental development</dt>
	<dd>Specification, development and validation are interleaved. The system is developed as a series of versions (increments), with each version adding functionality to the previous version. May be plan-driven or agile.</dd>

	<dt>Integration and configuration</dt>
	<dd>Based on the existence of a significant number of reusable components/systems. The system development process focuses on integrating these components into a system rather than developing them from scratch. May be plan-driven or agile.</dd>
</dl>

<p>In practice, most large systems are developed using a process that incorporates elements from all of these models.</p>




<div class="Underhead">
<p>The waterfall model</p>
</div>

<p><img src="./02-SoftwareProcesses_files/02-waterfall.png" width="80%"></p>

<p>There are separate identified <b>phases</b> in the waterfall model:</p>
<dl>
	<dt>Requirements analysis and definition</dt>
	<dd>The system's services, constraints, and goals are established by consultation with system users. They are then defined in detail and serve as a system specification.</dd>

	<dt>System and software design</dt>
	<dd>The systems design process allocates the requirements to either hardware or software systems by establishing an overall system architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships.</dd>

	<dt>Implementation and unit testing</dt>
	<dd>During this stage, the software design is realized as a set of programs or program units. Unit testing involves verifying that each unit meets its specification.</dd>

	<dt>Integration and system testing</dt>
	<dd>The individual program units or programs are integrated and tested as a complete system to ensure that the software requirements have been met. After testing, the software system is delivered to the customer.</dd>

	<dt>Operation and maintenance</dt>
	<dd>Normally (although not necessarily), this is the longest life cycle phase. The system is installed and put into practical use. Maintenance involves correcting errors which were not discovered in earlier stages of the life cycle, improving the implementation of system units and enhancing the system's services as new requirements are discovered.</dd>
</dl>

<p>The main drawback of the waterfall model is the difficulty of accommodating change after the process is underway. In principle, a phase has to be complete before moving onto the next phase. Waterfall model <b>problems</b> include:</p>
<dl>
	<dt>Difficult to address change</dt>
	<dd>Inflexible partitioning of the project into distinct stages makes it difficult to respond to changing customer requirements.
Therefore, this model is only appropriate when the <u>requirements are well-understood</u> and changes will be fairly limited during the design process.
Few business systems have stable requirements.</dd>

	<dt>Very few real-world applications</dt>
	<dd>The waterfall model is mostly used for large systems engineering projects where a system is developed at several sites.
In those circumstances, the plan-driven nature of the waterfall model helps coordinate the work. </dd>
</dl>




<div class="Underhead">
<p>Incremental development model</p>
</div>

<p><img src="./02-SoftwareProcesses_files/02-incremental_development.png" width="70%"></p>

<p><b>Benefits</b> of incremental development:</p>
<dl>
	<dt>Lower cost of changes </dt>
	<dd>The cost of accommodating changing customer requirements is reduced.
The amount of analysis and documentation that has to be redone is much less than is required with the waterfall model.</dd>

	<dt>Frequent feedback</dt>
	<dd>It is easier to get customer feedback on the development work that has been done. Customers can comment on demonstrations of the software and see how much has been implemented. </dd>

	<dt>Faster delivery</dt>
	<dd>More rapid delivery and deployment of useful software to the customer is possible. Customers are able to use and gain value from the software earlier than is possible with a waterfall process. </dd>
</dl>



<p><b>Problems</b> with incremental development (from the management perspective):</p>
<dl>
	<dt>The process is not visible</dt>
	<dd>Managers need regular deliverables to measure progress. If systems are developed quickly, it is not cost-effective to produce documents that reflect every version of the system. </dd>

	<dt>System structure tends to degrade as new increments are added</dt>
	<dd>Unless time and money is spent on refactoring to improve the software, regular change tends to corrupt its structure. Incorporating further software changes becomes increasingly difficult and costly. </dd>
</dl>



<div class="Underhead">
<p>Integration and configuration</p>
</div>

<p><img src="./02-SoftwareProcesses_files/02-reuse_oriented.png" width="100%"></p>

<p>This approach is based on systematic reuse where systems are integrated from existing components or COTS (Commercial-off-the-shelf) systems.
Process stages include:</p>
<ul>
	<li>Component analysis;</li>
	<li>Requirements modification;</li>
	<li>System design with reuse;</li>
	<li>Development and integration.</li>
</ul>

<p>Reuse is now the standard approach for building many types of business system.</p>

<p>Types of software components:</p>
<ul>
	<li><b>Web services</b> that are developed according to service standards and which are available for remote invocation. </li>
	<li>Collections of objects that are developed as a <b>package</b> to be integrated with a component framework such as .NET or J2EE.</li>
	<li>Stand-alone <b>commercial-off-the-shelf</b> systems (COTS) that are configured for use in a particular environment.</li>
</ul>



<div class="Underhead">
<p>Software process activities</p>
</div>

<p>Real software processes are inter-leaved sequences of technical, collaborative and managerial activities with the overall goal of specifying, designing, implementing and testing a software system. </p>

<p>The four basic process activities of specification, development, validation and evolution are organized differently in different development processes. In the waterfall model, they are organized in sequence, whereas in incremental development they are interleaved. </p>


<dl>
	<dt>Software specification</dt>
	<dd>The process of establishing what services are required and the constraints on the systemâ€™s operation and development.</dd>
	<dd>Requirements engineering process:</dd>
	<ul>
		<li><b>Feasibility study</b>: is it technically and financially feasible to build the system?</li>
		<li>Requirements <b>elicitation and analysis</b>: what do the system stakeholders require or expect from the system?</li>
		<li>Requirements <b>specification</b>: defining the requirements in detail</li>
		<li>Requirements <b>validation</b>: checking the validity of the requirements</li>
	</ul>

	<dt>Software design and implementation</dt>
	<dd>The process of converting the system specification into an executable system.</dd>
	<ul>
		<li><b>Software design</b>: design a software structure that realizes the specification;</li>
		<li><b>Implementation</b>: translate this structure into an executable program;</li>
	</ul>
	<dd>The activities of design and implementation are closely related and may be interleaved.</dd>
	<dd>Design activities include:</dd>
	<ul>
		<li><b>Architectural design</b>: identify the overall structure of the system, the principal components (sometimes called sub-systems or modules), their relationships and how they are distributed.</li>
		<li><b>Interface design</b>: define the interfaces between system components. </li>
		<li><b>Component design</b>: take each system component and design how it will operate. </li>
		<li><b>Database design</b>: design the system data structures and how these are to be represented in a database. </li>
	</ul>


	<dt>Software validation</dt>
	<dd>Verification and validation (V &amp; V) is intended to show that a system conforms to its specification and meets the requirements of the system customer.</dd>
	<ul>
		<li><b>Validation</b>: are we building the right product  (what the customer wants)?</li>
		<li><b>Verification</b>: are we building the product right?</li>
	</ul>
	<dd>V &amp; V involves checking and review processes and system testing. System testing involves executing the system with test cases that are derived from the specification of the real data to be processed by the system.</dd>
	<dd>Testing is the most commonly used V &amp; V activity and includes the following stages:</dd>
	<ul>
		<li><b>Development or component testing</b>: individual components are tested independently; components may be functions or objects or coherent groupings of these entities.</li>
		<li><b>System testing</b>: testing of the system as a whole, testing of emergent properties is particularly important.</li>
		<li><b>Acceptance testing</b>: testing with customer data to check that the system meets the customer's needs.</li>
	</ul>


	<dt>Software evolution</dt>
	<dd>Software is inherently flexible and can change.
As requirements change through changing business circumstances, the software that supports the business must also evolve and change.
Although there has been a demarcation between development and evolution (maintenance) this is increasingly irrelevant as fewer and fewer systems are completely new.</dd>
</dl>



<div class="Underhead">
<p>Coping with change</p>
</div>

<p>Change is inevitable in all large software projects.
Business changes lead to new and changed system requirements
New technologies open up new possibilities for improving implementations
Changing platforms require application changes
Change leads to rework so the costs of change include both rework (e.g. re-analyzing requirements) as well as the costs of implementing new functionality.</p>

<p>Two strategies to <b>reduce the costs</b> of rework:</p>
<dl>
	<dt>Change avoidance</dt>
	<dd>The software process includes activities that can anticipate possible changes before significant rework is required.
For example, a prototype system may be developed to show some key features of the system to customers. </dd>

	<dt>Change tolerance</dt>
	<dd>The process is designed so that changes can be accommodated at relatively low cost.
This normally involves some form of incremental development. Proposed changes may be implemented in increments that have not yet been developed. If this is impossible, then only a single increment (a small part of the system) may have be altered to incorporate the change.</dd>
</dl>



<div class="Underhead">
<p>Software prototyping</p>
</div>

<p>A prototype is an initial version of a system used to demonstrate concepts and try out design options. A prototype can be used in:</p>
<ul>
	<li>The requirements engineering process to help with requirements elicitation and validation;</li>
	<li>In design processes to explore options and develop a UI design;</li>
	<li>In the testing process to run back-to-back tests.</li>
</ul>

<p><b>Benefits</b> of prototyping:</p>
<ul>
	<li>Improved system usability.</li>
	<li>A closer match to users' real needs.</li>
	<li>Improved design quality.</li>
	<li>Improved maintainability.</li>
	<li>Reduced development effort.</li>
</ul>

<p>Prototypes may be based on rapid prototyping languages or tools. They may involve <b>leaving out functionality</b>:</p>
<ul>
	<li>Prototype should focus on areas of the product that are not well-understood;</li>
	<li>Error checking and recovery may not be included in the prototype;</li>
	<li>Focus on functional rather than non-functional requirements such as reliability and security.</li>
</ul>

<p>Prototypes should be <b>discarded</b> after development as they are not a good basis for a production system:</p>
<ul>
	<li>It may be impossible to tune the system to meet non-functional requirements;</li>
	<li>Prototypes are normally undocumented;</li>
	<li>The prototype structure is usually degraded through rapid change;</li>
	<li>The prototype probably will not meet normal organizational quality standards.</li>
</ul>



<div class="Underhead">
<p>Incremental development/delivery</p>
</div>
<p>Rather than deliver the system as a single delivery, the development and delivery is broken down into increments with each increment delivering part of the required functionality.
User requirements are prioritized and the highest priority requirements are included in early increments.
Once the development of an increment is started, the requirements are frozen though requirements for later increments can continue to evolve.</p>

<p><b>Advantages</b> of incremental delivery:</p>
<ul>
	<li>Customer value can be delivered with each increment so system functionality is available earlier.</li>
	<li>Early increments act as a prototype to help elicit requirements for later increments.</li>
	<li>Lower risk of overall project failure.</li>
	<li>The highest priority system services tend to receive the most testing.</li>
</ul>

<p>Incremental delivery <b>problems</b>:</p>
<ul>
	<li>Most systems require a set of basic facilities that are used by different parts of the system.
As requirements are not defined in detail until an increment is to be implemented, it can be hard to identify common facilities that are needed by all increments. </li>
	<li>The essence of iterative processes is that the specification is developed in conjunction with the software.
However, this conflicts with the procurement model of many organizations, where the complete system specification is part of the system development contract. </li>
</ul>


<div class="Underhead">
<p>Process improvement</p>
</div>
<p>Many software companies have turned to software process improvement as a way of enhancing the quality of their software, reducing costs or accelerating their development processes. Process improvement means understanding existing processes and changing these processes to increase product quality and/or reduce costs and development time. </p>
<dl>
	<dt>Process maturity approach</dt>
	<dd>Focuses on improving process  and project management and introducing good software engineering practice.
	The level of process maturity reflects the extent to which good technical and management practice has been
	adopted in organizational software development processes. </dd>
	<dt>Agile approach</dt>
	<dd>Focuses on iterative development and the reduction of overheads in the software process.
	The primary characteristics of agile methods are rapid delivery of functionality and responsiveness to changing customer requirements.</dd>
</dl>

<p><b>Process improvement activities</b> form a continuous cycle with a feedback loop:</p>
<ul>
	<li><b>Measure</b> one or more attributes of the software process or product.
	These measurements forms a baseline that help decide if process improvements have been effective.  </li>
	<li><b>Analyze</b> the current process and identify any bottlenecks. </li>
	<li><b>Change</b> the process to address some of the identified process weaknesses. These are introduced and the cycle resumes to collect data about the effectiveness of the changes.</li>
</ul>

<p><b>Process measurement</b></p>
<ul>
	<li>Wherever possible, quantitative process data should be collected.</li>
	<li>Process measurements should be used to assess process improvements.</li>
	<li>Metrics may include:
	<ul>
		<li>Time taken for process activities to be completed, e.g. calendar time or effort to complete an activity or process.</li>
		<li>Resources required for processes or activities, e.g. total effort in person-days.</li>
		<li>Number of occurrences of a particular event, e.g. number of defects discovered.</li>
	</ul>
	</li>
</ul>

<p><b>The SEI capability maturity model</b></p>
<ul>
	<li><b>Initial:</b> Essentially uncontrolled</li>
	<li><b>Repeatable:</b> Product management procedures defined and used</li>
	<li><b>Defined:</b> Process management procedures and strategies defined  and used</li>
	<li><b>Managed:</b> Quality management strategies defined and used</li>
	<li><b>Optimizing:</b> Process improvement strategies defined and used</li>
</ul>




</div>


</body></html>
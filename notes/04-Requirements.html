<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>CS 410/510 - Software Engineering class notes</title>
<link rel="stylesheet" type="text/css" href="../css/notes.css">
</head>

<body>

<div class="SimpleTitle">

<p>CS 410/510 - Software Engineering</p>
<p>Requirements Engineering</p>

</div>

<div class="Content">

<p>Reference: Sommerville, Software Engineering, 10 ed., Chapter 4</p>


<div class="Underhead">
<p>The big picture</p></div>


<p><b>Requirements engineering</b> (RE) is the process of establishing the services that the customer requires from a system and the constraints under which it operates and is developed.
The <b>requirements</b> themselves are the descriptions of the system services and constraints that are generated during the requirements engineering process. Requirements may range from a high-level abstract statement of a service or of a system constraint to a detailed mathematical functional specification. As much as possible, requirements should describe <b>what</b> the system should do, but <b>not how</b> it should do it.
</p>

<p>Two kinds of requirements based on the intended purpose and target audience:</p>
<dl>
	<dt>User requirements</dt>
	<dd>High-level abstract requirements written as statements, in a natural language plus diagrams, of what services the system is expected to provide to system users and the constraints under which it must operate.</dd>

	<dt>System requirements</dt>
	<dd>Detailed description of what the system should do including the software system's functions, services, and operational constraints. The system requirements document (sometimes called a functional specification) should define exactly what is to be implemented. It may be part of the contract between the system buyer and the software developers.</dd>
</dl>

<p>Three classes of requirements:</p>
<dl>
	<dt>Functional requirements</dt>
	<dd>Statements of services the system should provide, how the system should react to particular inputs and how the system should behave in particular situations.
May state what the system should not do.</dd>

	<dt>Non-functional requirements</dt>
	<dd>Constraints on the services or functions offered by the system such as timing constraints, constraints on the development process, standards, etc.
Often apply to the system as a whole rather than individual features or services.</dd>

	<dt>Domain requirements</dt>
	<dd>Constraints on the system from the domain of operation.</dd>
</dl>


<div class="Underhead">
<p>Functional requirements</p></div>

<p>Functional requirements describe <b>functionality</b> or system services.
They depend on the type of software, expected users and the type of system where the software is used.</p>
<ul>
	<li>Functional user requirements may be <b>high-level statements of what the system should do</b>.</li>
	<li>Functional system requirements should describe the system services in detail.</li>
</ul>

<p>Problems arise when requirements are not precisely stated.
Ambiguous requirements may be interpreted in different ways by developers and users. In principle, requirements should be both</p>
<ul>
	<li><b>Complete</b>: they should include descriptions of all facilities required, and</li>
	<li><b>Consistent</b>: there should be no conflicts or contradictions in the descriptions of the system facilities.</li>
</ul>

<p>In practice, it is impossible to produce a complete and consistent requirements document.</p>




<div class="Underhead">
<p>Non-functional requirements</p></div>

<p>Non-functional requirements define system properties and constraints e.g. reliability, response time and storage requirements. Constraints are I/O device capability, system representations, etc.
Process requirements may also be specified mandating a particular IDE, programming language or development method.
Non-functional requirements may be more critical than functional requirements. If these are not met, the system may be useless.</p>

<p>Non-functional requirements may affect the overall architecture of a system rather than the individual components.
A single non-functional requirement, such as a security requirement, may generate a number of related functional requirements that define system services that are required.
It may also generate requirements that restrict existing requirements. </p>

<p><img src="./04-Requirements_files/04-nonfunctional_requirement_types.png" width="100%"></p>


<p>Three classes of non-functional requirements:</p>
<dl>
	<dt>Product requirements</dt>
	<dd>Requirements which specify that the delivered product must behave in a particular way e.g. execution speed, reliability, etc.</dd>

	<dt>Organizational requirements</dt>
	<dd>Requirements which are a consequence of organizational policies and procedures e.g. process standards used, implementation requirements, etc.</dd>

	<dt>External requirements</dt>
	<dd>Requirements which arise from factors which are external to the system and its development process e.g. interoperability requirements, legislative requirements, etc.</dd>
</dl>


<p>Non-functional requirements may be very difficult to state precisely and imprecise requirements may be difficult to verify. If they are stated as a <b>goal</b> (a general intention of the user such as ease of use), they should be rewritten as a <b>verifiable</b> non-functional requirement (a statement using some <b>quantifiable metric</b> that can be objectively tested).
Goals are helpful to developers as they convey the intentions of the system users.</p>





<div class="Underhead">
<p>Domain requirements</p></div>

<p>The system's operational domain imposes requirements on the system.
Domain requirements may be new functional requirements, constraints on existing requirements or define specific computations.
If domain requirements are not satisfied, the system may be unworkable. Two main <b>problems</b> with domain requirements:</p>
<dl>
	<dt>Understandability</dt>
	<dd>Requirements are expressed in the language of the application domain, which is not always understood by software engineers developing the system.</dd>

	<dt>Implicitness</dt>
	<dd>Domain specialists understand the area so well that they do not think of making the domain requirements explicit.</dd>
</dl>






<div class="Underhead">
<p>Requirements engineering process</p></div>

<p>Processes vary widely depending on the application domain, the people involved and the organization developing the requirements.
In practice, requirements engineering is an <b>iterative process</b>, in which the following generic activities are interleaved:</p>
<ul>
	<li>Requirements <b>elicitation</b>;</li>
	<li>Requirements <b>analysis</b>;</li>
	<li>Requirements <b>validation</b>;</li>
	<li>Requirements <b>management</b>.</li>
</ul>



<div class="Underhead">
<p>Requirements elicitation and analysis</p></div>

<p>Software engineers work with a range of system <b>stakeholders</b> to find out about the application domain, the services that the system should provide, the required system performance, hardware constraints, other systems, etc. Stages include:</p>
<dl>
	<dt>Requirements discovery</dt>
	<dd>Interacting with stakeholders to discover their requirements. Domain requirements are also discovered at this stage. </dd>



	<dt>Requirements classification and organization</dt>
	<dd>Groups related requirements and organizes them into coherent clusters.</dd>

	<dt>Prioritization and negotiation</dt>
	<dd>Prioritizing requirements and resolving requirements conflicts.</dd>

	<dt>Requirements specification</dt>
	<dd>Requirements are documented and input into the next round of the spiral.</dd>
</dl>

<p>Closed (based on pre-determined list of questions) and open <b>interviews</b> with stakeholders are a part of the RE process. <b> User stories</b> and <b>scenarios</b> are real-life examples of how a system can be used, which are usually easy for stakeholders to understand. Scenarios should include descriptions of the starting situation, normal flow of events, what can go wrong, other concurrent activities, the state of the system when the scenario finishes. </p>

<p><a name="usecasediagrams"><b>Use-cases</b></a> are a scenario-based technique in the UML which identify the actors in an interaction and which describe the interaction itself. A set of use cases should describe all possible interactions with the system.</p>

<p><img src="./04-Requirements_files/04-use_case_diagram.png" width="70%"></p>

<p><b>Problems</b> to look for during requirements elicitation and analysis:</p>
<ul>
	<li><b>Stakeholders don't know what they really want.</b></li>
	<li>Stakeholders express requirements in their own terms.</li>
	<li>Different stakeholders may have conflicting requirements.</li>
	<li>Organizational and political factors may influence the system requirements.</li>
	<li>The requirements change during the analysis process. </li>
	<li>New stakeholders may emerge and the business environment may change.</li>
</ul>







<div class="Underhead">
<p>Requirements specification</p></div>

<p>Requirements specification is the process of <b>writing down the user and system requirements</b> in a requirements document.
User requirements have to be understandable by end-users and customers who do not have a technical background.
System requirements are more detailed requirements and may include more technical information.
The requirements may be part of a contract for the system development and it is important that these are as complete as possible.</p>

<p>In principle, requirements should state what the system should do and the design should describe how it does this.
In practice, <b>requirements and design are inseparable</b>.</p>

<p>User requirements are almost always written in <b>natural language</b> supplemented
by appropriate diagrams and tables in the requirements document. System requirements may also be written in natural language but other notations based on forms, graphical system models, or mathematical system models can also be used. Natural language is expressive, intuitive and universal. This means that the requirements  can be understood by users and customers.
</p>

<p><b>Structured natural language</b> is a way of writing system requirements where the freedom of the requirements writer is limited and all requirements are written in a standard way. This approach maintains most of the expressiveness and understand-ability of natural language but ensures that some uniformity is imposed on the specification.</p>







<div class="Underhead">
<p>Requirements validation</p></div>

<p>Requirements validation is concerned with demonstrating that the requirements define the system that the customer really wants.
Requirements error costs are high so validation is very important.</p>

<p>What <b>problems</b> to look for:</p>
<ul>
	<li><b>Validity</b>: does the system provide the functions which best support the customer's needs?</li>
	<li><b>Consistency</b>: are there any requirements conflicts?</li>
	<li><b>Completeness</b>: are all functions required by the customer included?</li>
	<li><b>Realism</b>: can the requirements be implemented given available budget and technology?</li>
	<li><b>Verifiability</b>: can the requirements be checked?</li>
</ul>

<p>Requirements validation <b>techniques</b>:</p>
<dl>
	<dt>Requirements reviews</dt>
	<dd>Systematic manual analysis of the requirements. Regular reviews should be held while the requirements definition is being formulated. What to look for:</dd>
		<ul>
			<li><b>Verifiability</b>: is the requirement realistically testable?</li>
			<li><b>Comprehensibility</b>: is the requirement properly understood?</li>
			<li><b>Traceability</b>: is the origin of the requirement clearly stated?</li>
			<li><b>Adaptability</b>: can the requirement be changed without a large impact on other requirements?</li>
		</ul>

	<dt>Prototyping</dt>
	<dd>Using an executable model of the system to check requirements. </dd>

	<dt>Test-case generation</dt>
	<dd>Developing tests for requirements to check testability.</dd>
</dl>




<div class="Underhead">
<p>Requirements change</p></div>

<p>Requirements management is the process of managing changing requirements during the requirements engineering process and system development.
New requirements emerge as a system is being developed and after it has gone into use. Reasons why requirements change after the system's deployment:</p>
<ul>
	<li>The business and technical environment of the system always changes after installation. </li>
	<li>The people who pay for a system and the users of that system are rarely the same people. </li>
	<li>Large systems usually have a diverse user community, with many users having different requirements and priorities that may be conflicting or contradictory. </li>
</ul>










</div>


</body></html>